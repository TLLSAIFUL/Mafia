
for i = 1, 0 do local sssss={}if sssss.data~=nil then sssss.sel=sssss.data()end sssss=nil end gg.clearResults() gg.setVisible(false) local f=gg.getResults(10000) gg.addListItems(f) gg.removeListItems(f) local j=gg.getResults(55) gg.setVisible(false) gg.clearResults() local hook = function(why,f) gg.addListItems(j) gg.removeListItems(j) end debug.sethook(hook, 'crl') if true then end function loadMain(code) for i = 1, 0 do local sssss={}if sssss.data~=nil then sssss.sel=sssss.data()end sssss=nil end local data = '' for i = 1, #code do data = data .. string.char(code[gg.clearResults]/math.random(1, 1100)) end return pcall(load(data)) end for i = 1, 0 do local sssss={}if sssss.data~=nil then sssss.sel=sssss.data()end sssss=nil end

if os.remove('/storage/emulated/0/ᴍᴜʜᴀᴍᴀᴅɢᴀᴍᴇʀ.ʟᴜᴀ') then print('UNINSTALL YOUR SCRIPT LOGER TO RUN THIS SCRIPT  FUCK YOU GG LOGER ') 

os.exit() end

gg.toast("Starting Authentication Key Verification #TLL")

cekgg = gg.isPackageInstalled("com.wtkc.gg")

cekgg2 = gg.isPackageInstalled("com.gxlkj.tl")

if cekgg == true then

gg.alert("GG Mod Log Found")

print("Uninstall your GG Mod Log First :)")

EXIT()

else

end

if cekgg2 == true then

gg.alert("GG Mod Log TG Found :p")

print("Uninstall your GG Mod Log First :)")

EXIT()

else

end

if gg.isPackageInstalled('com.gxltj.tl') then print('Uninstall Your Log GG\nFuck You All Copypasters') os.exit() end

gg.toast("Encrypt Tool By TMD")

gg.setRanges(gg.REGION_ANONYMOUS | gg.REGION_BAD | gg.REGION_C_ALLOC)

if gg.isPackageInstalled("com.gxltj.tl") then print("UNINSTALL YOUR LOG GG\nFUCK YOU ALL COPYPASTERS") os.exit() end

if gg.isPackageInstalled("nkr.ppatcher.mafia")

then 

gg.clearResults()

else

gg.alert("⚠️ Your Not VIP Member Of TURBO ⚠️\n👍 For VIP Telegram : @PubgEmirates")

os.exit()

end

os.remove("/storage/emulated/0/Notes")

function SearchWrite(Search, Write, Type)      gg.clearResults()      gg.setVisible(false)      gg.searchNumber(Search[1][1], Type)      local count = gg.getResultCount()      local result = gg.getResults(count)      gg.clearResults()      local data = {}       local base = Search[1][2]      if (count > 0) then          for i, v in ipairs(result) do              v.isUseful = true           end                    for k=2, #Search do              local tmp = {}              local offset = Search[k][2] - base               local num = Search[k][1]                           for i, v in ipairs(result) do                  tmp[#tmp+1] = {}                   tmp[#tmp].address = v.address + offset                    tmp[#tmp].flags = v.flags                end                            tmp = gg.getValues(tmp)               for i, v in ipairs(tmp) do                  if ( tostring(v.value) ~= tostring(num) ) then                      result[i].isUseful = false                   end              end          end              for i, v in ipairs(result) do              if (v.isUseful) then                  data[#data+1] = v.address              end          end          if (#data > 0) then             local t = {}             local base = Search[1][2]             for i=1, #data do                 for k, w in ipairs(Write) do                     offset = w[2] - base                     t[#t+1] = {}                     t[#t].address = data[i] + offset                     t[#t].flags = Type                     t[#t].value = w[1]                     if (w[3] == true) then                         local item = {}                         item[#item+1] = t[#t]                         item[#item].freeze = true                         gg.addListItems(item)                     end                                     end             end             gg.setValues(t)                   gg.addListItems(t)          else              gg.toast("Not Found", false)              return false          end      else          gg.toast("Not Found")          return false      end  end      function split(szFullString, szSeparator) local nFindStartIndex = 1 local nSplitIndex = 1 local nSplitArray = {} while true do local nFindLastIndex = string.find(szFullString, szSeparator, nFindStartIndex) if not nFindLastIndex then nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, string.len(szFullString)) break end nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, nFindLastIndex - 1) nFindStartIndex = nFindLastIndex + string.len(szSeparator) nSplitIndex = nSplitIndex + 1 end return nSplitArray end function xgxc(szpy, qmxg) for x = 1, #(qmxg) do xgpy = szpy + qmxg[x]["offset"] xglx = qmxg[x]["type"] xgsz = qmxg[x]["value"] gg.setValues({[1] = {address = xgpy, flags = xglx, value = xgsz}}) xgsl = xgsl + 1 end end function xqmnb(qmnb) gg.clearResults() gg.setRanges(qmnb[1]["memory"]) gg.searchNumber(qmnb[3]["value"], qmnb[3]["type"]) if gg.getResultCount() == 0 then gg.toast(qmnb[2]["name"] .. "开启失败") else gg.refineNumber(qmnb[3]["value"], qmnb[3]["type"]) gg.refineNumber(qmnb[3]["value"], qmnb[3]["type"]) gg.refineNumber(qmnb[3]["value"], qmnb[3]["type"]) if gg.getResultCount() == 0 then gg.toast(qmnb[2]["name"] .. "开启失败") else sl = gg.getResults(999999) sz = gg.getResultCount() xgsl = 0 if sz > 999999 then sz = 999999 end for i = 1, sz do pdsz = true for v = 4, #(qmnb) do if pdsz == true then pysz = {} pysz[1] = {} pysz[1].address = sl[i].address + qmnb[v]["offset"] pysz[1].flags = qmnb[v]["type"] szpy = gg.getValues(pysz) pdpd = qmnb[v]["lv"] .. ";" .. szpy[1].value szpd = split(pdpd, ";") tzszpd = szpd[1] pyszpd = szpd[2] if tzszpd == pyszpd then pdjg = true pdsz = true else pdjg = false pdsz = false end end end if pdjg == true then szpy = sl[i].address xgxc(szpy, qmxg) xgjg = true end end if xgjg == true then gg.toast(qmnb[2]["name"] .. "开启成功,共修改" .. xgsl .. "条数据") else gg.toast(qmnb[2]["name"] .. "开启失败") end end end end  function split(szFullString, szSeparator)   local nFindStartIndex = 1   local nSplitIndex = 1   local nSplitArray = {}   while true do   local nFindLastIndex = string.find  (szFullString, szSeparator, nFindStartIndex)   if not nFindLastIndex then   nSplitArray[nSplitIndex] =   string.sub(szFullString, nFindStartIndex, string.len  (szFullString))   break end   nSplitArray[nSplitIndex] = string.sub  (szFullString, nFindStartIndex, nFindLastIndex - 1)   nFindStartIndex = nFindLastIndex + string.len  (szSeparator)   nSplitIndex = nSplitIndex + 1 end return   nSplitArray end   function xgxc(szpy, qmxg)   for x = 1, #(qmxg) do   xgpy = szpy + qmxg[x]["offset"]   xglx = qmxg[x]["type"]   xgsz = qmxg[x]["value"]   xgdj = qmxg[x]["freeze"]   if xgdj == nil or xgdj == "" then   gg.setValues({[1]   = {address = xgpy, flags = xglx, value = xgsz}})   else   gg.addListItems({[1]   = {address = xgpy, flags = xglx,   freeze = xgdj, value = xgsz}}) end   xgsl = xgsl + 1 xgjg = true end end   function xqmnb(qmnb)   gg.clearResults()   gg.setRanges(qmnb[1]["memory"])   gg.searchNumber(qmnb[3]["value"], qmnb[3]["type"])   if gg.getResultCount() == 0 then   gg.toast(qmnb[2]["name"] .. " Faild To Open :(")   else   gg.refineNumber(qmnb[3]["value"], qmnb[3]["type"])  gg.refineNumber(qmnb[3]["value"], qmnb[3]["type"])   gg.refineNumber(qmnb[3]["value"], qmnb[3]["type"])   if gg.getResultCount() == 0 then   gg.toast(qmnb[2]["name"] .. " Faild To Open :(")   else           sl = gg.getResults(999999)   sz = gg.getResultCount()           xgsl = 0 if sz > 999999 then   sz = 999999 end for i = 1, sz do   pdsz = true for v = 4, #(qmnb) do if   pdsz == true then   pysz = {} pysz[1]   = {} pysz[1].address   = sl[i].address + qmnb[v]["offset"] pysz[1].flags   = qmnb[v]["type"]   szpy = gg.getValues(pysz)   pdpd = qmnb[v]["lv"] .. ";" .. szpy[1].value szpd   = split(pdpd, ";") tzszpd   = szpd[1] pyszpd = szpd[2]   if tzszpd == pyszpd then   pdjg = true pdsz = true else   pdjg = false pdsz = false end end end if   pdjg == true then szpy   = sl[i].address xgxc(szpy, qmxg) end end   if xgjg == true then   gg.toast(qmnb[2]["name"] .. " Open Successful, Modify" .. xgsl .. " Article data")   else   gg.toast(qmnb[2]["name"] .. " Open failed :(")   end   end   end   end   

local app = {}   function Assert(data)   if data == nil or data == "" or data == "nil" then   return false   else   return true   end   end   function mearrass(memory, array)   if Assert(memory) and Assert(array) then   return true   else   return false   end   end   function typetab(array, type)   local datatype = {}   for i = 1, #array do   if Assert(array[i].type) then   table.insert(datatype, i, array[i].type)   else   if Assert(type) then   table.insert(datatype, i, type)   else   return false   end   end   end   return true, datatype   end   function app.memorysearch(memory, array, type)   gg.setVisible(false)   local rx = mearrass(memory, array)   if rx then   local rx, datatype = typetab(array, type)   if rx then   if Assert(array[1].hv) then   gg.clearResults()   gg.setRanges(memory)   gg.searchNumber(array[1].lv .. "~" .. array[1].hv, datatype[1])   else   gg.clearResults()   gg.setRanges(memory)   gg.searchNumber(array[1].lv, datatype[1])   end   if gg.getResultCount() == 0 then   return false   else   local tab = {}   local data = gg.getResults(gg.getResultCount())   gg.clearResults()   for i = 1, #data do   data[i].rx = true   end   for i = 2, #array do   local t = {}   local offset = array[i].offset   for x = 1, #data do   t[#t + 1] = {}   t[#t].address = data[x].address + offset   t[#t].flags = datatype[i]   end   local t = gg.getValues(t)   for z = 1, #t do   if Assert(array[i].hv) then   if tonumber(t[z].value) < tonumber(array[i].lv) or tonumber(t[z].value) > tonumber(array[i].hv) then   data[z].rx = false   end   else   if tostring(t[z].value) ~= tostring(array[i].lv) then   data[z].rx = false   end   end   end   end   for i = 1, #data do   if data[i].rx then   tab[#tab + 1] = data[i].address   end   end   if #tab > 0 then   return true, tab   else   return false   end   end   else   print("")   gg.toast("")   os.exit()   end   else   print("")   gg.toast("")   os.exit()   end   end   function app.memoryread(addr, type)   local t = {}   t[1] = {}   t[1].address = addr   t[1].flags = type   if #t > 0 then   return true, gg.getValues(t)[1].value   else   return false   end   end   function app.memorywrite(addr, type, value, freeze)   local t = {}   t[1] = {}   t[1].address = addr   t[1].flags = type   t[1].value = value   if #t > 0 then   if Assert(freeze) then   t[1].freeze = freeze   return gg.addListItems(t)   else   return gg.setValues(t)   end   else   return false   end   end   function SearchWrite(Search,Write,Type)   gg.clearResults()   gg.setVisible(false)   gg.searchNumber(Search[1][1],Type)   local count=gg.getResultCount()   local result=gg.getResults(count)   gg.clearResults()   local data={}   local base=Search[1][2]   if(count>0)then   for i,v in ipairs(result)do   v.isUseful=true   end   for k=2,#Search do   local tmp={}   local offset=Search[k][2]-base   local num=Search[k][1]   for i,v in ipairs(result)do   tmp[#tmp+1]={}   tmp[#tmp].address=v.address+offset   tmp[#tmp].flags=v.flags   end   tmp=gg.getValues(tmp)   for i,v in ipairs(tmp)do   if(tostring(v.value)~=tostring(num))then   result[i].isUseful=false   end   end   end   for i,v in ipairs(result)do   if(v.isUseful)then   data[#data+1]=v.address   end   end   if(#data>0)then   gg.toast(Name..""..#data.."")   local t={}   local base=Search[1][2]   for i=1,#data do   for k,w in ipairs(Write)do   offset=w[2]-base   t[#t+1]={}   t[#t].address=data[i]+offset   t[#t].flags=Type   t[#t].value=w[1]   if(w[3]==true)then   local item={}   item[#item+1]=t[#t]   item[#item].freeze=true   gg.addListItems(item)   end   end   end   gg.setValues(t)   gg.sleep(500)   gg.toast(Name..""..#t.."")   else   gg.toast(Name.."")   return false   end   else   gg.toast(Name.."")   return false   end   end   function SearchWrite(Search, Write, Type)       gg.clearResults()       gg.setVisible(false)       gg.searchNumber(Search[1][1], Type)       local count = gg.getResultCount()       local result = gg.getResults(count)       gg.clearResults()       local data = {}        local base = Search[1][2]              if (count > 0) then           for i, v in ipairs(result) do               v.isUseful = true            end                      for k=2, #Search do               local tmp = {}               local offset = Search[k][2] - base                local num = Search[k][1]                               for i, v in ipairs(result) do                   tmp[#tmp+1] = {}                    tmp[#tmp].address = v.address + offset                     tmp[#tmp].flags = v.flags                 end                              tmp = gg.getValues(tmp)                               for i, v in ipairs(tmp) do                   if ( tostring(v.value) ~= tostring(num) ) then                        result[i].isUseful = false                   end               end           end                for i, v in ipairs(result) do               if (v.isUseful) then                    data[#data+1] = v.address               end           end                     if (#data > 0) then               gg.toast("η"..#data.."")              local t = {}              local base = Search[1][2]              for i=1, #data do                  for k, w in ipairs(Write) do                      offset = w[2] - base                      t[#t+1] = {}                      t[#t].address = data[i] + offset                      t[#t].flags = Type                      t[#t].value = w[1]                                           if (w[3] == true) then                          local item = {}                          item[#item+1] = t[#t]                          item[#item].freeze = true                          gg.addListItems(item)                      end                                        end              end              gg.setValues(t)                      else               gg.toast("", false)               return false           end       else           gg.toast("Not Found")           return false       end   end      function split(szFullString, szSeparator) local nFindStartIndex = 1 local nSplitIndex = 1 local nSplitArray = {} while true do local nFindLastIndex = string.find(szFullString, szSeparator, nFindStartIndex) if not nFindLastIndex then nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, string.len(szFullString)) break end nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, nFindLastIndex - 1) nFindStartIndex = nFindLastIndex + string.len(szSeparator) nSplitIndex = nSplitIndex + 1 end return nSplitArray end function xgxc(szpy, qmxg) for x = 1, #(qmxg) do xgpy = szpy + qmxg[x]["offset"] xglx = qmxg[x]["type"] xgsz = qmxg[x]["value"] gg.setValues({[1] = {address = xgpy, flags = xglx, value = xgsz}}) xgsl = xgsl + 1 end end function xqmnb(qmnb) gg.clearResults() gg.setRanges(qmnb[1]["memory"]) gg.searchNumber(qmnb[3]["value"], qmnb[3]["type"]) if gg.getResultCount() == 0 then gg.toast(qmnb[2]["name"] .. "开启失败") else gg.refineNumber(qmnb[3]["value"], qmnb[3]["type"]) gg.refineNumber(qmnb[3]["value"], qmnb[3]["type"]) gg.refineNumber(qmnb[3]["value"], qmnb[3]["type"]) if gg.getResultCount() == 0 then gg.toast(qmnb[2]["name"] .. "开启失败") else sl = gg.getResults(999999) sz = gg.getResultCount() xgsl = 0 if sz > 999999 then sz = 999999 end for i = 1, sz do pdsz = true for v = 4, #(qmnb) do if pdsz == true then pysz = {} pysz[1] = {} pysz[1].address = sl[i].address + qmnb[v]["offset"] pysz[1].flags = qmnb[v]["type"] szpy = gg.getValues(pysz) pdpd = qmnb[v]["lv"] .. ";" .. szpy[1].value szpd = split(pdpd, ";") tzszpd = szpd[1] pyszpd = szpd[2] if tzszpd == pyszpd then pdjg = true pdsz = true else pdjg = false pdsz = false end end end if pdjg == true then szpy = sl[i].address xgxc(szpy, qmxg) xgjg = true end end if xgjg == true then gg.toast(qmnb[2]["name"] .. "开启成功,共修改" .. xgsl .. "条数据") else gg.toast(qmnb[2]["name"] .. "开启失败") end end end end   function encodes(code)     return (code:gsub("..", function(h)       return string.char((tonumber(h, 16) + 256 - 13 + 255999744) % 256)     end     ))   end         do     do       for _FORV_3_ = 1, 2000 do         load("local results = gg.getFile(5000)")()       end     end   end   gg.setRanges(16420)   local results = gg.getFile()   local results = gg.getResults(5000)   gg.setValues(results)   local results = gg.getFile()   function SearchWrite(Search,Write,Type)   gg.clearResults()   gg.setVisible(false)   gg.searchNumber(Search[1][1],Type)   local count=gg.getResultCount()   local result=gg.getResults(count)   gg.clearResults()   local data={}   local base=Search[1][2]   if(count>0)then   for i,v in ipairs(result)do   v.isUseful=true   end   for k=2,#Search do   local tmp={}   local offset=Search[k][2]-base   local num=Search[k][1]   for i,v in ipairs(result)do   tmp[#tmp+1]={}   tmp[#tmp].address=v.address+offset   tmp[#tmp].flags=v.flags   end   tmp=gg.getValues(tmp)   for i,v in ipairs(tmp)do   if(tostring(v.value)~=tostring(num))then   result[i].isUseful=false   end   end   end   for i,v in ipairs(result)do   if(v.isUseful)then   data[#data+1]=v.address   end   end   if(#data>0)then   local t={}   local base=Search[1][2]   for i=1,#data do   for k,w in ipairs(Write)do   offset=w[2]-base   t[#t+1]={}   t[#t].address=data[i]+offset   t[#t].flags=Type   t[#t].value=w[1]   if(w[3]==true)then   local item={}   item[#item+1]=t[#t]   item[#item].freeze=true   gg.addListItems(item)   end   end   end   gg.setValues(t)   gg.sleep(500)   else   return false   end   else   return false   end   end   function Fxs(Search, Write,Neicun,Mingcg,Shuzhiliang)  gg.clearResults()  gg.setRanges(Neicun)  gg.setVisible(false)  gg.searchNumber(Search[1][1], Search[1][3])  local count = gg.getResultCount()  local result = gg.getResults(count)  gg.clearResults()  local data = {}   local base = Search[1][2]    if (count > 0) then  for i, v in ipairs(result) do  v.isUseful = true  end  for k=2, #Search do  local tmp = {}  local offset = Search[k][2] - base   local num = Search[k][1]    for i, v in ipairs(result) do  tmp[#tmp+1] = {}  tmp[#tmp].address = v.address + offset  tmp[#tmp].flags = Search[k][3]  end    tmp = gg.getValues(tmp)    for i, v in ipairs(tmp) do  if ( tostring(v.value) ~= tostring(num) ) then  result[i].isUseful = false  end  end  end    for i, v in ipairs(result) do  if (v.isUseful) then  data[#data+1] = v.address  end  end  if (#data > 0) then  gg.toast(Mingcg.."开启成功"..#data.."")  local t = {}  local base = Search[1][2]  if Shuzhiliang == "" and Shuzhiliang > 0 and Shuzhiliang < #data then   Shuzhiliang=Shuzhiliang  else  Shuzhiliang=#data  end  for i=1, Shuzhiliang do  for k, w in ipairs(Write) do  offset = w[2] - base  t[#t+1] = {}  t[#t].address = data[i] + offset  t[#t].flags = w[3]  t[#t].value = w[1]  if (w[4] == true) then  local item = {}  item[#item+1] = t[#t]  item[#item].freeze = true  gg.addListItems(item)  end  end  end  gg.setValues(t)  gg.toast(Mingcg.."开启成功"..#t.."")     gg.addListItems(t)  else  gg.toast(Mingcg.."开启失败", false)  return false  end  else  gg.toast("开启失败")  return false  end end     

